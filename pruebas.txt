Mi Opinión y Sugerencia de Ajuste Menor:

Tu orden es bueno, pero te sugiero un pequeño ajuste para ir de lo más sencillo y autocontenido a lo más complejo que depende de otras partes (como Edge Functions o flujos multi-paso):

✅ Selectores (Idioma y Vista Inicial): Implementar la selección (con un modal/dropdown simple) y el guardado. (Empezamos aquí).
✅ Página "Cambiar Contraseña": Crear ChangePassword.html y ChangePassword.js. Es una funcionalidad frontend completa y estándar.
✅ Toggle 2FA (Guardado + Inicio Flujo): Ya guarda el estado. Podemos añadir la llamada inicial desde el JS para empezar el proceso de activación de Supabase MFA (ej: supabase.auth.mfa.enroll()), pero el resto del flujo (mostrar QR, verificar código) lo dejamos para después.
✅ Botón Eliminar Cuenta (Llamada Segura): Añadir en el JS la llamada a una futura Edge Function (supabase.functions.invoke('delete-user-account')) después de las confirmaciones. La creación de la Edge Function en sí se hace después.
⬜️ Backend/Edge Functions: Crear las funciones necesarias para Eliminar Cuenta, Exportar/Importar, Notificaciones.
⬜️ Completar Flujo 2FA: Desarrollar la interfaz y lógica para mostrar QR, verificar códigos, etc.
⬜️ Internacionalización (i18n): Aplicar el idioma guardado a toda la app.
⬜️ Aplicar Vista Inicial: Modificar auth-listener.js para usar esta preferencia.
⬜️ Tema Global: Aplicar CSS de modo oscuro a todas las páginas.
Básicamente, propongo hacer la Página de Cambiar Contraseña (tu punto 6) antes de meternos a fondo con el flujo de 2FA o la lógica segura de eliminación (tus puntos 2 y 3), ya que la página de cambio de contraseña es más directa de implementar ahora mismo. Para 2FA y Eliminar, podemos preparar la llamada desde el frontend y dejar la parte compleja (Supabase MFA API, Edge Functions) para un bloque de trabajo posterior.


Sugerencia Revisada:

Dado el gran impacto de implementar i18n ahora, te sugiero este orden:

Crear Edge Function export-data: Es una tarea más aislada y útil. Terminamos una funcionalidad pendiente de Settings.
Retomar Maquetación: Maquetar Inversiones (o Informes/Dashboard si prefieres). Esto completa más la estructura visual antes de refactorizar todo para i18n.
Implementar i18n: Una vez que tengas la mayoría de las páginas maquetadas, abordar la internacionalización será más eficiente porque ya tendrás casi todo el texto definido.
Aplicar Vista Inicial y Tema Global: Como pasos finales de refinamiento.
Importar Datos y Notificaciones (Backend): Dejar para el final o fases posteriores.

async function handleGenerateReport() {
        if (isLoading || !supabase || !currentUserId) return;
        hideMessage(); // Ocultar mensajes previos

        // 1. Recopilar TODOS los filtros seleccionados del estado 'filters' y UI
        //    (Asegúrate que los listeners de los filtros actualizan correctamente el objeto 'filters')
        const currentFilters = {
             dateFrom: dateFromInput?.value || null,
             dateTo: dateToInput?.value || null,
             type: filterTypeSelector?.querySelector('.type-option.active')?.dataset.type || 'all',
             accountId: filters.accountId, // Ya debería estar actualizado por el modal
             categoryId: filters.categoryId, // Ya debería estar actualizado por el modal
             tripId: selectedReportType === 'trip_expenses' ? tripFilterSelect?.value || null : null
        };
        const format = formatSelector?.querySelector('.format-option.active')?.dataset.format || 'csv';


        // 2. Validaciones Frontend
        if (selectedReportType === 'trip_expenses' && !currentFilters.tripId) {
            showMessage('error', 'Debes seleccionar un viaje para exportar sus gastos.'); return; }
        if (currentFilters.dateFrom && currentFilters.dateTo && new Date(currentFilters.dateTo) < new Date(currentFilters.dateFrom)) {
             showMessage('error', 'La fecha "Hasta" no puede ser anterior a la fecha "Desde".'); return; }
        if (format === 'pdf') { // Aunque el botón esté deshabilitado, añadimos la alerta
             showMessage('info', 'La generación de PDF aún no está implementada. Se generará CSV.');
             // selectedFormat = 'csv'; // Forzar si fuera necesario
         }

        
        const payload = {
            reportType: selectedReportType,
            filters: currentFilters,
            format: 'csv' // Forzamos CSV por ahora
        };

        console.log("Generando informe con:", { selectedReportType, filters: currentFilters, format: 'csv' }); // Forzamos CSV
        setLoadingState(true);

        try {
            // 3. Llamar a la Edge Function 'generate-filtered-report'
            //console.log("Payload Object being sent to invoke:", payload);
            console.log("--- DEBUG: Enviando payload de prueba SIMPLE ---");
            const testPayloadSimple = { prueba: "datos basicos", numero: 1 };
            
            const { data, error } = await supabase.functions.invoke('generate_filtered_report', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: testPayloadSimple // <-- OBJETO SIMPLE
            });
            console.log("--- DEBUG: Respuesta a payload de prueba SIMPLE:", { data, error });
            return;
            // ***** INICIO CAMBIO IMPORTANTE *****
            //const { data, error } = await supabase.functions.invoke('generate_filtered_report', {
            //    method: 'POST',
            //    headers: {
            //        'Content-Type': 'application/json', // <- Indica que enviamos JSON
            //        // 'Accept' lo maneja el navegador/librería
            //    },
            //    body: payload // <- PASA EL OBJETO JAVASCRIPT DIRECTAMENTE
                             // NO USAR JSON.stringify() aquí. invoke() lo hará.
            //});

             // Manejar error de INVOCACIÓN (red, CORS, crash de función)
             if (error) {
                console.error("Error invocando Edge Function 'generate_filtered_report':", error);
                // Intentar dar un mensaje más específico
                let displayError = error.message || 'Error al contactar con el servicio de informes.';
                if (error.message.toLowerCase().includes('failed to fetch')) {
                    displayError = "Error de red o CORS al llamar a la función de informes.";
                } else if (error.message.toLowerCase().includes('function not found')) {
                     displayError = "Error: El servicio de informes no está disponible.";
                } else if (error.message.toLowerCase().includes('non-2xx status code')){
                    // Si el error es por non-2xx, intentamos obtener el mensaje del body si es JSON
                     try {
                        // Intentamos parsear el 'context' o 'message' que a veces viene en el error
                        // La estructura exacta puede variar, esto es un intento
                        const errorDetails = JSON.parse(error.context || error.message || '{}');
                        if(errorDetails.error) {
                            displayError = `Error en la función de informes: ${errorDetails.error}`;
                        } else {
                            displayError = `Error ${error.code || 'desconocido'} desde la función de informes. Revisa los logs de Supabase.`;
                        }
                     } catch(parseError) {
                         // Si no se puede parsear, usamos el mensaje genérico
                         displayError = `La función de informes devolvió un error (código ${error.code || 'desconocido'}). Revisa los logs de Supabase.`;
                     }
                }
                 throw new Error(displayError);
             }

            // 4. Procesar respuesta de la función (data)
            //    La función devuelve JSON si está vacío o hay error interno,
            //    o devuelve CSV con cabeceras de descarga si hay datos.

            if (data && data.error) { // Si la función devolvió un error JSON estructurado
                 throw new Error(data.error);
             } else if (data && data.status === 'empty') { // Si la función indicó que no hay datos
                 console.log("Generación completada, no había datos.");
                 // Usar el modal informativo
                  openInfoModal('Informe Vacío', data.message || "No se encontraron datos con los filtros seleccionados.");
             } else {
                 // Éxito - La función devolvió CSV, el navegador debería iniciar descarga
                 console.log("Llamada a generate_filtered_report exitosa, descarga debería iniciarse.");
                 // Podríamos mostrar un mensaje temporal de éxito si quisiéramos
                 // showMessage('success', '¡Informe generado! Iniciando descarga...');
                 // setTimeout(hideMessage, 3000);
             }

        } catch (error) {
             console.error('Error generando informe:', error);
             // Mostrar error en el modal informativo o en el área de mensajes
             // openInfoModal('Error al Generar', `No se pudo generar el informe: ${error.message}`);
             showMessage('error', `Error al generar el informe: ${error.message}`); // Usamos el área de mensajes de la página
        } finally {
            setLoadingState(false);
        }
    }